#+TITLE: Chapter 1 

* First contact with S-expressions

#+begin_src racket :lang sicp
  (+ (* 3
        (+ (* 2 4)
           (+ 3 5)))
     (+ (- 10 7)
        6))
#+end_src

* Exercise 1

#+begin_src racket :lang sicp
  10 		
  (+ 5 3 4)
  (- 9 1) 
  (/ 6 2)
  (+ (* 2 4) (- 4 6)) 
  (define a 3) 		
  (define b (+ a 1))
  (+ a b (* a b)) 
  (= a b) 	

  (if (and (> b a) (< b (* a b)))
      b
      a) 		

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25)) 	

  (+ 2 (if (> b a) b a)) 

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1)) 
#+end_src

#+RESULTS:
: 16

* Exercise 2

#+begin_src racket :lang sicp 
  (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
     (* 3 (- 6 2) (- 2 7))) 
#+end_src

#+RESULTS:
: -37/150


* Exercise 3
This solution is too explicit, it is better to define a procedure that adds the sum of two squares.

#+begin_src racket :lang sicp
  (define (sqlar a b c)
    (cond ((and (<= a b) (<= a c)) (+ (* b b) (* c c)))
	  ((and (<= b a) (<= b c)) (+ (* a a) (* c c)))
	  (else (+ (* a a) (* b b)))))
  (sqlar 1 2 3)
#+end_src

#+RESULTS:
: 13

* Exercise 4
This procedure adds or subtract the numbers a and b depending on the sign of b:

#+begin_src racket :lang sicp
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
  (a-plus-abs-b 1 2)
#+end_src

#+RESULTS:
: 3

* Exercise 5
- Normal-order: fully expand and then reduce
- Applicative-order: evaluate the arguments and then apply
  
In applicative-order the expression will enter an infinite loop. In normal-order the answer is zero:

#+begin_src racket :lang sicp
  (define (p) (p))
  (define (test x y)
    (if (= x 0) 0 y))

  (test 0 (p))
#+end_src

* Exercise 6

The =sqrt= procedure can be tested with and without the =new-if= procedure here:

#+begin_src racket :lang sicp
  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))

  (define (sqrt-iter guess x)
    (if (quality-of-guess? guess x)
        guess
        (sqrt-iter (improve-guess guess x) x)))

  (define (square x)
    (* x x))

  (define (abs x)
    (cond ((< x 0) (- x))
          (else x)))

  (define (quality-of-guess? guess x)
    (< (abs (- (square guess) x)) 0.001))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve-guess guess x)
    (average guess (/ x guess)))

  (define (sqrt x)
    (sqrt-iter 1.0 x))

  (sqrt 0.000001)
#+end_src

#+RESULTS:
: 0.031260655525445276

If we toggle the =new-if= procedure instead of the =if= special form the applicative order of Scheme will bite us
and we will enter and infinite loop, in particular due to the third parameter.

* Exercise 7

The usual limitations of floating point arithmetic apply here. Squaring big numbers can result in overflow,
adding very small and large numbers lead to loss of precision. For large number the separation between two
consecutive numbers is bigger. In addition, the initial absolute tolerance of 0.001 will be obviously
insufficient to deal with numbers smaller than it. 

#+begin_src racket :lang sicp
  (define (quality-of-guess? guess x)
    (< (abs (- guess
               (improve-guess guess x)))
       (* (abs guess) 0.01)))
#+end_src

* Exercise 8

Implementing the cube root formula.

#+begin_src racket :lang sicp
  (define (cubic-iter guess x)
    (if (quality-of-guess? guess x)
        guess
        (cubic-iter (improve-cubic-guess guess x) x)))

  (define (improve-cubic-guess guess x)
    (/ (+ (/ x (* guess guess))
          (* guess 2))
       3))

  (define (quality-of-guess? guess x)
    (< (abs (- guess
               (improve-cubic-guess guess x)))
       (* (abs guess) 0.001)))

  (define (cubert x)
    (cubic-iter 1.0 x))

  (cubert 100)
#+end_src

#+RESULTS:
: 4.6440247053200965
